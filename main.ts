import * as cdktf from "cdktf";

/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";

import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";

class MyStack extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);

    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
    const defaultTags = new cdktf.TerraformVariable(this, "default_tags", {
      default: [
        {
          project: "Learning Live with AWS & HashiCorp",
        },
      ],
      description: "Map of default tags to apply to resources",
    });
    const privateSubnetCount = new cdktf.TerraformVariable(
      this,
      "private_subnet_count",
      {
        default: 2,
        description: "Number of private subnets to create",
      }
    );
    const publicSubnetCount = new cdktf.TerraformVariable(
      this,
      "public_subnet_count",
      {
        default: 2,
        description: "Number of public subnets to create",
      }
    );
    const region = new cdktf.TerraformVariable(this, "region", {
      default: "us-east-1",
      description: "The region to deploy resources to",
    });
    const vpcCidr = new cdktf.TerraformVariable(this, "vpc_cidr", {
      default: "10.255.0.0/20",
      description: "CIDR block for VPC",
    });
    const awsEipNat = new aws.ec2.Eip(this, "nat", {
      tags: {
        Name: `\${${defaultTags.project.value}}-nat-eip`,
      },
      vpc: true,
    });
    const awsVpcMain = new aws.vpc.Vpc(this, "main", {
      assignGeneratedIpv6CidrBlock: true,
      cidrBlock: vpcCidr.value,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      instanceTenancy: "default",
      tags: {
        Name: `\${${defaultTags.project.value}}-vpc`,
      },
    });
    const dataAwsAvailabilityZonesAvailable =
      new aws.datasources.DataAwsAvailabilityZones(this, "available", {
        state: "available",
      });
    new aws.AwsProvider(this, "aws", {
      defaultTags: {
        tags: defaultTags.value,
      },
      region: region.value,
    });
    const awsInternetGatewayGw = new aws.vpc.InternetGateway(this, "gw", {
      tags: {
        Name: `\${${defaultTags.project.value}}-internet-gateway`,
      },
      vpcId: awsVpcMain.id,
    });
    const awsRouteTablePrivate = new aws.vpc.RouteTable(this, "private", {
      tags: {
        Name: `\${${defaultTags.project.value}}-private-route-table`,
      },
      vpcId: awsVpcMain.id,
    });
    const awsRouteTablePublic = new aws.vpc.RouteTable(this, "public", {
      tags: {
        Name: `\${${defaultTags.project.value}}-public-route-table`,
      },
      vpcId: awsVpcMain.id,
    });
    const awsSubnetPrivate = new aws.vpc.Subnet(this, "private_12", {
      availabilityZone: `\${${dataAwsAvailabilityZonesAvailable.names.fqn}[count.index]}`,
      cidrBlock: `\${cidrsubnet(${awsVpcMain.cidrBlock}, 4, count.index + ${publicSubnetCount.value})}`,
      tags: {
        Name: `\${${defaultTags.project.value}}-private-\${${dataAwsAvailabilityZonesAvailable.names.fqn}[count.index]}`,
      },
      vpcId: awsVpcMain.id,
    });

    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsSubnetPrivate.overrideLogicalId("private");

    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsSubnetPrivate.addOverride("count", privateSubnetCount.value);
    const awsSubnetPublic = new aws.vpc.Subnet(this, "public_13", {
      assignIpv6AddressOnCreation: true,
      availabilityZone: `\${${dataAwsAvailabilityZonesAvailable.names.fqn}[count.index]}`,
      cidrBlock: `\${cidrsubnet(${awsVpcMain.cidrBlock}, 4, count.index)}`,
      ipv6CidrBlock: `\${cidrsubnet(${awsVpcMain.ipv6CidrBlock}, 8, count.index)}`,
      mapPublicIpOnLaunch: true,
      tags: {
        Name: `\${${defaultTags.project.value}}-public-\${${dataAwsAvailabilityZonesAvailable.names.fqn}[count.index]}`,
      },
      vpcId: awsVpcMain.id,
    });

    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsSubnetPublic.overrideLogicalId("public");

    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsSubnetPublic.addOverride("count", publicSubnetCount.value);
    const awsNatGatewayNat = new aws.vpc.NatGateway(this, "nat_14", {
      allocationId: awsEipNat.id,
      depends_on: [`\${${awsEipNat.fqn}}`, `\${${awsInternetGatewayGw.fqn}}`],
      subnetId: `\${${awsSubnetPublic.fqn}.0.id}`,
      tags: {
        Name: `\${${defaultTags.project.value}}-nat`,
      },
    });

    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsNatGatewayNat.overrideLogicalId("nat");
    new aws.vpc.Route(this, "private_internet_access", {
      destinationCidrBlock: "0.0.0.0/0",
      natGatewayId: awsNatGatewayNat.id,
      routeTableId: awsRouteTablePrivate.id,
    });
    new aws.vpc.Route(this, "public_internet_access", {
      destinationCidrBlock: "0.0.0.0/0",
      gatewayId: awsInternetGatewayGw.id,
      routeTableId: awsRouteTablePublic.id,
    });
    const awsRouteTableAssociationPrivate = new aws.vpc.RouteTableAssociation(
      this,
      "private_17",
      {
        routeTableId: awsRouteTablePrivate.id,
        subnetId: `\${element(${awsSubnetPrivate.fqn}.*.id, count.index)}`,
      }
    );

    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRouteTableAssociationPrivate.overrideLogicalId("private");

    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsRouteTableAssociationPrivate.addOverride(
      "count",
      privateSubnetCount.value
    );
    const awsRouteTableAssociationPublic = new aws.vpc.RouteTableAssociation(
      this,
      "public_18",
      {
        routeTableId: awsRouteTablePublic.id,
        subnetId: `\${element(${awsSubnetPublic.fqn}.*.id, count.index)}`,
      }
    );

    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRouteTableAssociationPublic.overrideLogicalId("public");

    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsRouteTableAssociationPublic.addOverride(
      "count",
      publicSubnetCount.value
    );
  }
}

const app = new App();
new MyStack(app, "cdktf-aws-networking-demo");
app.synth();
